        -:    0:Source:unittest5.c
        -:    0:Programs:2
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:#include <stdlib.h>
        -:    8:
        -:    9:
        -:   10://this is the unit test for the ambassador function
function main called 1 returned 100% blocks executed 82%
        1:   11:int main () {
        -:   12://int tribute(int currentPlayer, int nextPlayer, int tributeRevealedCards, struct gameState *state){
        1:   13:printf("%s", "This is the test for the tribute card\n");
call    0 returned 1
        -:   14:
        -:   15:
        1:   16:int currentPlayer = 0;
        1:   17:int nextPlayer = 1;
        -:   18:int tributeRevealedCards[2];
        -:   19://setting up the test case taken from the example
        -:   20:struct gameState G, testG, testk;
        1:   21:int numPlayers = 2;
        1:   22:int seed = 1000;
        1:   23:int k[10] = {ambassador, gold, silver, minion, mine, cutpurse,
        -:   24:			sea_hag, tribute, smithy, council_room};
        1:   25:initializeGame(numPlayers, k, seed, &G);
call    0 returned 1
        1:   26:memcpy(&testG, &G, sizeof(struct gameState));
        1:   27:testG.deck[1][5] = smithy;
        1:   28:testG.deck[1][6] = mine;
        1:   29:testG.deck[1][7] = mine;
        1:   30:testG.deck[1][8] = smithy;
        1:   31:tribute_function(currentPlayer, nextPlayer, tributeRevealedCards, &testG);
call    0 returned 1
        -:   32:
        -:   33://first test to find the first bug, which is an assignment bug, finding it requires commenting out a later for loop 
        -:   34://that has the second bug.
        1:   35:if (tributeRevealedCards[1] == -1){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   36:    printf("%s", "There is a bug in the tribute logic.\n");
call    0 never executed
        -:   37:}
        -:   38:else {
        1:   39:    printf("%s""%d", "The check to see if the cards are the same that are revealed works.\n"), tributeRevealedCards[0];
call    0 returned 1
        -:   40:
        -:   41:}
        1:   42:initializeGame(numPlayers, k, seed, &G);
call    0 returned 1
        1:   43:memcpy(&testk, &G, sizeof(struct gameState));
        1:   44:testk.deck[1][5] = smithy;
        1:   45:testk.deck[1][6] = mine;
        1:   46:testk.deck[1][7] = mine;
        1:   47:testk.deck[1][8] = smithy;
        1:   48:tribute_function(currentPlayer, nextPlayer, tributeRevealedCards, &testk);
call    0 returned 1
        -:   49://second test checks to see if the second revealed card equals smithy like it is supposed to. this finds
        -:   50://the second assignment bug which is setting it to copper instead of checking for copper.
        1:   51:if (tributeRevealedCards[1] == 13){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   52:    printf("%s", "The tribute funciton is working correctly.\n");
call    0 never executed
        -:   53:}
        -:   54:else {
        1:   55:    printf("%s""%d", "The tribute function is not correctly assigning tribute revealed cards.\n"), tributeRevealedCards[1];
call    0 returned 1
        -:   56:
        -:   57:}
        -:   58:
        -:   59://this test initializes the deckcount of the nextplayer with only one card.
        1:   60:initializeGame(numPlayers, k, seed, &G);
call    0 returned 1
        1:   61:memcpy(&testk, &G, sizeof(struct gameState));
        1:   62:testk.discardCount[1]=0;
        1:   63:testk.deckCount[1] = 1;
        1:   64:tribute_function(currentPlayer, nextPlayer, tributeRevealedCards, &testk);
call    0 returned 1
        -:   65:
        1:   66:if (testk.deckCount[1] == 0){
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   67:        printf("%s", "The tribute funciton is working correctly for a one card deck.\n");
call    0 returned 1
        -:   68:
        -:   69:}
        -:   70:else {
    #####:   71:            printf("%s", "The tribute funciton is  not working correctly.\n");
call    0 never executed
        -:   72:
        -:   73:}
        -:   74:
        -:   75://this test reverses the previous test and checks the discard pile
        1:   76:initializeGame(numPlayers, k, seed, &G);
call    0 returned 1
        1:   77:memcpy(&testk, &G, sizeof(struct gameState));
        1:   78:testk.discardCount[1]=1;
        1:   79:testk.deckCount[1] = 0;
        1:   80:tribute_function(currentPlayer, nextPlayer, tributeRevealedCards, &testk);
call    0 returned 1
        -:   81:
        1:   82:if (testk.discardCount[1] == 0){
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   83:        printf("%s", "The tribute funciton is working correctly for a no card deck.\n");
call    0 returned 1
        -:   84:
        -:   85:}
        -:   86:else {
    #####:   87:            printf("%s", "The tribute funciton is  not working correctly.\n");
call    0 never executed
        -:   88:
        -:   89:}
        -:   90:
        -:   91://this test reverses the previous test and checks the discard pile
        1:   92:initializeGame(numPlayers, k, seed, &G);
call    0 returned 1
        1:   93:memcpy(&testk, &G, sizeof(struct gameState));
        1:   94:testk.discardCount[1]=10;
        1:   95:testk.deckCount[1] = 0;
        1:   96:tribute_function(currentPlayer, nextPlayer, tributeRevealedCards, &testk);
call    0 returned 1
        -:   97:
        1:   98:if (testk.discardCount[1] == 5){
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   99:        printf("%s", "The tribute funciton is working correctly for a no card deck with a large discard pile.\n");
call    0 returned 1
        -:  100:
        -:  101:}
        -:  102:else {
    #####:  103:            printf("%s""%d", "The tribute funciton is not working correctly.\n", testk.discardCount[1]);
call    0 never executed
        -:  104:
        -:  105:}
        -:  106:
        1:  107:return 0;
        -:  108:}
