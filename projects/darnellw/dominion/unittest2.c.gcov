        -:    0:Source:unittest2.c
        -:    0:Programs:2
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:#include <stdlib.h>
        -:    8:
        -:    9:#define TESTCARD "baron"
        -:   10://int baron_function(int currentPlayer, struct gameState *state, int choice1)
function main called 1 returned 100% blocks executed 72%
        1:   11:int main () {
        -:   12:
        1:   13:int choice1 = 1;
        1:   14:int currentPlayer = 0;
        -:   15://setting up the test case taken from the example
        -:   16:struct gameState G, testG;
        1:   17:int numPlayers = 2;
        1:   18:int seed = 1000;
        1:   19:int k[10] = {estate, gold, silver, minion, mine, cutpurse,
        -:   20:			sea_hag, tribute, smithy, council_room};
        1:   21:initializeGame(numPlayers, k, seed, &G);
call    0 returned 1
        1:   22:memcpy(&testG, &G, sizeof(struct gameState));
        -:   23:
        1:   24:printf("%s", "This is the test for the baron card\n");
call    0 returned 1
        1:   25:baron_function(currentPlayer, &testG, choice1);
call    0 returned 1
        -:   26:
        -:   27://test for number of buys increasing by one
        -:   28:
        1:   29:if (testG.numBuys == ++G.numBuys){
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   30:    printf("%s", "the number of buys was incremented correctly.\n");
call    0 returned 1
        -:   31:}
        -:   32:else {
    #####:   33:     printf("%s", "the number of buys was NOT incremented correctly.\n");
call    0 never executed
        -:   34:}
        -:   35:
        -:   36://this function finds the first bug that I entered, which was changing the boolean flag to start as false, which 
        -:   37://made the first branch never execute but I am going to change that flag back in the source code so that I can 
        -:   38://achieve test coverage.
        1:   39:if ((testG.coins == G.coins) && (testG.supplyCount[estate] == G.supplyCount[estate])){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 never executed
branch  3 never executed
    #####:   40:     printf("%s", "the function is not working properly and did not execute.\n");
call    0 never executed
        -:   41:}
        -:   42:else {
        1:   43:     printf("%s", "at least one branch of the function ran correctly.\n");
call    0 returned 1
        -:   44:}
        -:   45:
        -:   46://check the number of coins math
        -:   47://this test finds the second bug that I added, changing the coin change from + 4 to -4. 
        1:   48:if (testG.coins == (G.coins + 4)){
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:   49:    printf("%s", "The function is doing the math correctly since there is one estate card in the players hand.\n");
call    0 never executed
        -:   50:}
        -:   51:else {
        1:   52:    printf("%s", "the function is not doing the math correctly in terms of coins.\n");
call    0 returned 1
        -:   53:
        -:   54:}
        1:   55:choice1 = 0;
        -:   56://the case for executing the second branch
        1:   57:baron_function(currentPlayer, &testG, choice1);
call    0 returned 1
        -:   58:
        -:   59:
        -:   60://another test case for if the second player gains the estate card
        1:   61:choice1 = 1;
        1:   62:int j[10] = {curse, gold, silver, minion, mine, cutpurse,
        -:   63:			sea_hag, tribute, estate, council_room};
        1:   64:initializeGame(numPlayers, j, seed, &G);
call    0 returned 1
        -:   65:struct gameState testF;
        1:   66:memcpy(&testF, &G, sizeof(struct gameState));
        1:   67:testF.supplyCount[estate] = 1;
        -:   68:
        1:   69:baron_function(1, &testF, choice1);
call    0 returned 1
        1:   70:G.supplyCount[estate] = 1;
        -:   71:
        -:   72://test to see if the supply count is double decremented when supply is 1. is a bug in the gain card function.
        1:   73:if (testF.supplyCount[estate] == (G.supplyCount[estate] - 2)){
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   74:    printf("%s", "The estate card was successfully removed from the supply.\n");
call    0 returned 1
        1:   75:    printf("%d", testF.supplyCount[estate]);
call    0 returned 1
        1:   76:    printf("%d", G.supplyCount[estate]);
call    0 returned 1
        -:   77:
        -:   78:
        -:   79:
        -:   80:}
        -:   81:else {
    #####:   82:    printf("%s", "the estate card was not successfully removed from the supply.\n");
call    0 never executed
    #####:   83:    printf("%d", testF.supplyCount[estate]);
call    0 never executed
    #####:   84:    printf("%d", G.supplyCount[estate]);
call    0 never executed
        -:   85:}
        1:   86:return 0;
        -:   87:}
